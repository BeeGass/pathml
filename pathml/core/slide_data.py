import h5py
import dask.distributed
from torch.utils.data import Dataset
from pathlib import Path

import pathml.core.masks
import pathml.core.tile
import pathml.core.tiles
import pathml.core.slide_backends
import pathml.core.h5path
import pathml.preprocessing.pipeline

class SlideData:
    """
    Main class representing a slide and its annotations. 

    Args:
        filepath (str, optional): Path to slide file on disk.
        name (str, optional): name of slide
        slide_backend (pathml.core.slide_backends.SlideBackend, optional): slide backend object for interfacing with
            slide on disk.
            If ``None``, and a filepath is provided, defaults to :class:`~pathml.core.slide_backends.OpenSlideBackend`
        masks (pathml.core.masks.Masks, optional): object containing {key, mask} pairs
        tiles (pathml.core.tiles.Tiles, optional): object containing {coordinates, tile} pairs
        labels (collections.OrderedDict, optional): dictionary containing {key, label} pairs
    """
    def __init__(self, filepath=None, name=None, slide_backend=None, masks=None, tiles=None, labels=None, history=None):
        # check inputs
        assert masks is None or isinstance(masks, (Masks, h5py._hl.group.Group)), \
            f"mask are of type {type(masks)} but must be type Masks or h5 group"
        assert labels is None or isinstance(labels, dict), \
            f"labels are of type {type(labels)} but must be of type dict. array-like labels should be stored in masks."
        assert tiles is None or isinstance(tiles, (Tiles, h5py._hl.group.Group)), \
            f"tiles are of type {type(tiles)} but must be of type pathml.core.tiles.Tiles"
        assert slide_backend is None or issubclass(slide_backend, SlideBackend), \
            f"slide_backend is of type {type(slide_backend)} but must be a subclass of pathml.core.slide_backends.SlideBackend"

        # load slide using OpenSlideBackend if path is provided and backend is not specified
        if filepath is not None:
            if slide_backend is None:
                slide_backend = OpenSlideBackend
            self.slide = slide_backend(filepath)
        else:
            self.slide = None

        self.slide_backend = slide_backend
        self.name = name
        self.masks = masks
        self.tiles = tiles
        self.labels = labels
        self.history = history

    def __repr__(self): 
        out = f"{self.__class__.__name__}(name={self.name}, "
        out += f"slide = {repr(self.slide)}, "
        out += f"masks={repr(self.masks)}, "
        out += f"tiles={repr(self.tiles)}, "
        out += f"labels={repr(self.labels)}, "
        out += f"history={self.history})"
        return out 

    def run(self, pipeline, tile_size=3000, tile_stride=None, level=0, tile_pad=False):
        """
        Run a preprocessing pipeline on SlideData.
        Tiles are generated by calling self.generate_tiles() and pipeline is applied to each tile.

        Args:
            pipeline (pathml.preprocessing.pipeline.Pipeline): Preprocessing pipeline.
            tile_size (int, optional): Size of each tile. Defaults to 3000px
            tile_stride (int, optional): Stride between tiles. If ``None``, uses ``tile_stride = tile_size``
                for non-overlapping tiles. Defaults to ``None``.
            level (int, optional): Level to extract tiles from. Defaults to ``None``.
            tile_pad (bool): How to handle chunks on the edges. If ``True``, these edge chunks will be zero-padded
                symmetrically and yielded with the other chunks. If ``False``, incomplete edge chunks will be ignored.
                Defaults to ``False``.
        """
        assert isinstance(pipeline, Pipeline), \
            f"pipeline is of type {type(pipeline)} but must be of type pathml.preprocessing.pipeline.Pipeline"
        assert self.slide is not None, "cannot run pipeline because self.slide is None"

        if tile_stride is None:
            tile_stride = tile_size

        if self.tiles is None:
            self.tiles = Tiles()

        for tile in self.generate_tiles(level = level, shape = tile_size, stride = tile_stride, pad = tile_pad):
            pipeline.apply(tile)
            self.tiles.add(tile)

    def generate_tiles(self, shape=3000, stride=None, pad=False, level=0):
        """
        Generator over tiles.
        All pipelines must be composed of transforms acting on tiles.

        Args:
            shape (int or tuple(int)): Size of each tile. May be a tuple of (height, width) or a single integer,
                in which case square tiles of that size are generated.
            stride (int): stride between chunks. If ``None``, uses ``stride = size`` for non-overlapping chunks.
                Defaults to ``None``.
            pad (bool): How to handle chunks on the edges. If ``True``, these edge chunks will be zero-padded
                symmetrically and yielded with the other chunks. If ``False``, incomplete edge chunks will be ignored.
                Defaults to ``False``.
            level (int, optional): For slides with multiple levels, which level to extract tiles from.
                Defaults to 0 (highest resolution)

        Yields:
            np.ndarray: Extracted chunk of dimension (size, size, 3)
        """
        assert isinstance(shape, int) or (isinstance(shape, tuple) and len(shape) == 2), \
            f"input shape {shape} invalid. Must be a tuple of (H, W), or a single integer for square tiles"
        if isinstance(shape, int):
            shape = (shape, shape)
        assert stride is None or isinstance(stride, int) or (isinstance(stride, tuple) and len(stride) == 2), \
            f"input stride {stride} invalid. Must be a tuple of (stride_H, stride_W), or a single int"
        assert isinstance(level, int), f"level {level} invalid. Must be an int."

        if stride is None:
            stride = shape
        elif isinstance(stride, int):
            stride = (stride, stride)

        i, j = self.slide.get_image_shape(level = level)

        stride_i, stride_j = stride

        if pad:
            n_chunk_i = i // stride_i + 1
            n_chunk_j = j // stride_j + 1

        else:
            n_chunk_i = (i - shape[0]) // stride_i + 1
            n_chunk_j = (j - shape[1]) // stride_j + 1

        for ix_i in range(n_chunk_i):
            for ix_j in range(n_chunk_j):
                coords = (int(ix_j * stride_j), int(ix_i * stride_i))
                # get image for tile
                tile_im = self.slide.extract_region(location = coords, size = shape, level = level)
                # get mask(s) for tile
                tile_masks = None
                if self.masks is not None:
                    slices = [
                        slice(int(ix_i * stride_i), int(ix_i * stride_i) + shape[0]),
                        slice(int(ix_j * stride_j), int(ix_j * stride_j) + shape[1])
                    ]
                    tile_masks = self.masks.slice(slices)
                yield Tile(image = tile_im, coords = coords, masks = tile_masks, slidetype = type(self))

    def plot(self):
        raise NotImplementedError

    def write(self, path):
        pathml.core.h5path.write_h5path(self, path)
